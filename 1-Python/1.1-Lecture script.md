Slide 1

 

Welcome to this session on Computational thinking for problem-solving. I am Dr. Shehan Perera from the Department of Computer Science and Engineering University of Moratuwa. At the end of this session, you will be able to see what is computational thinking, why we need it, and how we can solve problems using computational thinking. 

This session is the first session in a series of sessions that are part of a course in python basics that is designed to help you to learn and get started on programming in python.

Once you get started on python you can also take the other courses that we offer specifically designed for you so that if you complete all the courses successfully you will be able to become a software developer that has sufficient knowledge and skills to get started on a career as an entry-level Software Developer.

 

Slide 2

We do use a standard colour coding scheme to make it easy for you to find the important points in the slides.  We use Red for very important points, Blue to highlight points that are not as important as the points given in Red. We use Green for Terminology, and Purple for other content that is slightly off-topic but important to know.

Slide 3 This is a basic outline of the session. We will cover computational thinking and a little bit about computer systems including the history of computing. Slide 4

Sri Lanka is currently considered as one of the top destinations in the world to visit.  Let’s say you want to go on a trip to Sigiriya, a very interesting place to visit as it is an ancient rock fortress built by a Sri Lankan King. For some, planning the trip could be a problem. When do you go, how do you go, with whom do you go, what do you do there, where do you eat……. All the problems need to be solved before you do. Let us see how we can use computational thinking to solve this problem. You are already using computational thinking to solve problems.

 

Slide 5

So what is computational thinking? 

It can be used to solve problems. The basic problem-solving concepts and ideas come from Computer Science. The good thing is, if you can use computational thinking to solve problems, you can also use computers to give the solution to the problem. At the moment we have so many problems to solve. If we can at least solve a few problems that would be great. 

Computational thinking is NOT computer programming. In this course, you will be learning computer programming. You will learn the basics of python programming. We can use computational thinking to solve a problem and then write a computer program to get a computer to solve the problem using a computer.

 

Slide 6

Today we use computers to solve a lot of our problems in Engineering, Medicine, Agriculture, Social Science, Military. You can name many areas, there would be a solution given by using a computer or a computing device. That is why there is a big demand for Software Engineers, people who can use computational thinking and solve problems using computers. We would also like to see those of you who follow this course and complete, become productive citizens of the world, solving problems.

 

Slide 7

Getting back to Computational Thinking, we can also solve our problem of going to Sigiriya. 

 

Slide 8

There are 4 parts to computational thinking. We will look at each one of them separately with our example of solving the problem of going to Sigiriya. Once you look at some examples you will understand these clearly. But for now, let's look at what they are.

The first one is Decomposition. That is to break a bigger problem into smaller parts so that we can solve the smaller problems rather than getting stuck on solving the bigger problem. 

The second one is pattern recognition. In this, we try to see things that are common to multiple similar problems so that we can re-use the solution to solve a similar problem. 

The third one is abstraction. In this, we try to focus or look at the important things of the problem or the details that matter to solve the problem and ignore the other things that may not need our attention at the moment. 

Fourth we have Algorithm Design, where we come out with step-by-step instructions to solve a problem so that we can use the steps to solve the problem, and also another person can solve a problem by going through the same steps.

 

Slide 9

Decomposition allows us to break a problem into smaller parts so that we can solve the small parts separately and combine the solutions to solve the bigger problem. This is something that we do to solve our problems also.

For example, on our trip to Sigiriya, we may want to break the things that we need to solve into multiple parts and think about what to do in each part separately without thinking about the entire trip at once. In our example rather than trying to think about what we are going to do for the entire day at once, we can break it into morning, noon, and afternoon. Or the first 70 Km, next 70, and the final 62 KM. Also, we can break it into sub-parts of what food to eat and ask the girls to solve that part, Sites to visit separately, and the transport separately. When breaking the problem we can even break the subparts into smaller parts to make it easier for us to solve the problem. So breaking a bigger problem into smaller parts for the purpose of solving the problem is decomposition. In each part, we can go into the details of the specific things that we need to solve and concentrate on solving that part. Once we complete solving all the parts we have the solution for the entire problem.

 

 

Slide 10

In pattern recognition, we try to see if we can find similar patterns in problems so that we can re-use the solutions for similar problems. By using a solution that we have used earlier will help us to solve problems faster and efficiently.

So to solve the problem of where to visit in our trip to Sigiriya we can check to see if we have gone to Sigiriya earlier, and where did we visit when we went to Sigiriya last time, or are there other people who had gone to Sigiriya and where did they visit on the way to Sigiriya. Rather than looking at all the interesting sites in Sri Lanka, we can look at what others have done and do the same or slightly modify it and use it. If we want to decide on the time to leave, we can look at what time did we leave on our last trip.  It may not be to Sigiriya. How about the time we went to Kandy or Badulla? Was it 8 AM? Maybe 8 AM is a good time to leave because it worked last time and maybe a few other times.

What mode of transport did we use? Did we use public transport or a private bus on our last trip?  We may not realize those are patterns that we have observed in the past and solution patterns that we have used to solve problems. These patterns help us to answer a similar question that we need to answer now.

 

Slide 11

Abstraction allows us to look at the general characteristics of the problem without all the details.

For example for our trip to Sigiriya, Who are we going to invite for the trip? Without going into the details of the names of people, we can think of friends, family, colleagues, etc. Without going into the exact cost for the trip or per person cost, we can think about the fact that we need money for the trip. Without going into the exact places, we want to visit we can think about the fact that we need to have other sites to visit. When planning the overall trip if we use abstraction, we need to look at the 1. Participants, 2. Cost 3. Sites. By looking at the list of items like this we know that we can solve this problem.

It helps us to solve problems by looking at the overall problem from a higher level rather than with all the details. Also, the entire trip can be looked at going from the starting point to the destination without going to the details of the cities that we are going to pass on the way. Also, abstraction helps us produce a common way to solve the problem and then use it to solve other similar problems. For example, if we want to go to Matara in the south next year we may be able to use a similar solution by changing the destination to Matara and a few other specific things.

Slide 12

Algorithm design is a way to discover step-by-step instructions on how to solve a problem and also give those instructions for another person to solve the problem. For example when we go on the trip we will be visiting multiple sites. So what do we do there coming up with the set of instructions on what to do would be an algorithm. We may want to give information about the site including, Do’s don'ts what to take, etc. Take a count of the people, Get down from the vehicle, visit the site, stop for refreshments, stop at the gift shop, return to the vehicle, take a count. Etc We can use the same algorithm for all the sites.

Slide 13

We can also think of the overall problem of scheduling the trip as an algorithm. We plan the sites; We collect all the people going on the trip; The sequence of things we do; We check to see if it is raining. We will have to stay in the bus, so we take our umbrellas and caps. If it is not a rainy day, we don’t take them. That is an example of a Decision in an algorithm. We find a vehicle and visit the sites. Until we have visited all the sites, we repeat and finish all the sites. Example of a repetition.

We can represent this algorithm as a flow chart. We will learn more about flow charts when we learn programming. For now, think of it as a diagram that can help us to put the steps that are required to solve a problem. In the diagram, we have a sequence of steps that we do at the start of the trip. Then we have to take a decision about if we want to take umbrellas and caps, and finally, we need a repletion to make sure that we visit all the sites. Also, we need to indicate where to start the solution and where it ends.

 

We can also represent the same solution using a pseudocode. Pseudocode is a way of writing a solution to the problem in an informal way for us to represent how we solved the problem, and also for other people to understand how we solved the problem.  Pseudocode is not a programming language, but we can easily convert the pseudocode to a programming language like Python or Java, or any other programming language.

Now that we have a way to solve problems and also a way to represent it so that others can also understand and use the same steps to solve it. We can also think of getting machines to solve the problems for us if we can build a machine or a computer to take each step and do what we ask it to do.

 

Slide 14

Humans use tools to help them.

They use tools or machines to solve their problems. The earliest use of a machine to solve the problem of calculating is found in the use of the Abacus. We could do any addition, subtraction, division, or multiplication. It does not matter if the numbers are 3 and 5 or 300 and 500 the machine could help us to calculate the answer. But it was a simple machine built for calculations only.

Slide 15

The next computing machine we see in history was built by Charles Babbage who wanted to come out with a machine where we can solve different problems that have different solutions.

Difference Engine is a machine that can be adjusted to the problem that we want to solve. It was possible to create a simple algorithm as a solution for a problem and use this engine to solve the problem. This was a mechanical machine that had lots of wheels and arms similar to what we have in a mechanical clock, that worked together to give us the solution.

Each time we want to solve a new problem we had to change the settings of the machine by adjusting the wheels and how they are connected to each other to solve the problem. But still, it was better than the abacus, since it was able to solve different categories of problems other than basic calculations.

Slide 16

After that, we see the use of electricity and electronics to build machines to solve our problems. ENIAC was one of the first computers that were able to solve different problems, and also we were able to give the algorithm to the machine much more easier than how it was with the mechanical machine. It was a huge machine and there were lot of devices and wires going all over the place connecting the components and transferring electrical signals to come out with the solution.

Slide 17

Going further, Von Neuman was able to separate the data, and the instructions or the steps used to solve the problem from the engine or the processor that is used to execute the instructions and process the data.

This is like writing what you learn in your mathematics class on how to solve a problem in a book, and when you are given a problem to solve you look at the book on how to solve the problem and solve the problem.

Now using computers we can solve different problems with different data because of the separation of the data and the steps to solve it from the engine that is solving it.

We have computers that have a separate memory to keep the data and the instructions to solve it and a separate processing unit that can take the instructions and the data and give us the solution. The memory unit will be like a large box where we can put all the data we want to process and also the instructions on how to solve the problem. The processing unit will take instructions one at a time, and the corresponding data and processor to do the calculation to produce the solution that we want.

Slide 18

Based on Von Neuman’s idea we can look at the modern computer where we have a memory unit and the Processing unit. 

The processing unit has a control unit that keeps track of the overall operation, and an arithmetic and a logical unit that can process instructions given to it. 

The memory unit has the data and the instructions. We also can connect input devices such as keyboards and thumb drives to give the instructions and the data and also output devices such as the computer screens and the printers to show the solution to the problem.

Slide 19

If we look at the summary of what we have covered in this session, we looked at computational thinking by looking at an example of solving the problem of going on a trip.

We looked at how we can decompose the problem and break it into smaller pieces so that we can solve each part separately then we looked at pattern recognition to find similar patterns in problems and their solutions.

Then we looked at Abstraction to look at a problem from a distance so that we can get away from the details of the problem and solve it. Also, we looked at algorithms to come out with step-by-step instructions to solve a problem and tell someone how to solve the same problem.

We also very briefly looked at how historically we have used computing machines to solve our problems.

We also looked at the different parts of a computer at a very high level so that we can understand how it solves problems.

Now that we know about computational thinking and how to solve problems using computational thinking, we need to know how we can write the solutions to the problem using a language that the computer can understand. I can tell you how to go to Sigiriya in English or Sinhala or Tamil. Similar to that we need a programming language such as Python to communicate with the computer and tell how to solve the problem. That is what we going to learn in Python programming.

Let's meet with another session on how to solve problems using computers by writing code in Python, teach you how to use computation to accomplish a variety of goals, and provide you with a brief introduction to a variety of topics in computational problem-solving.